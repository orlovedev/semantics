# @priestine/semantics

[![pipeline](https://gitlab.com/priestine/semantics/badges/master/pipeline.svg)](https://gitlab.com/priestine/semantics) [![codecov](https://codecov.io/gl/priestine/semantics/branch/master/graph/badge.svg)](https://codecov.io/gl/priestine/semantics) [![licence: MIT](https://img.shields.io/npm/l/@priestine/semantics.svg)](https://gitlab.com/priestine/semantics) [![docs: typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](https://priestine.gitlab.io/semantics) [![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg)](https://github.com/prettier/prettier) [![versioning: semantics](https://img.shields.io/badge/versioning-semantics-912e5c.svg)](https://gitlab.com/priestine/semantics)

`@priestine/semantics` automates version bumping for your projects. It determines the next version number (you need to follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0-beta.2/#specificationg) for it to work correctly), generates the release notes and publishes the release tag (only GitLab is currently supported).

## Features

* Automated versioning that follows [SemVer](https://semver.org/) spec
* Automatically generated release notes
* Simple and transparent way of releasing your code
* Support for formalized commits that follow widely adopted specifications
* Support for any language
* Simple integration with CI/CD
* Docker image for your entertainment
* Unopinionated behaviour (except for requirements of following SemVer and Conventional Commits)
* Easy-to-use interface for referencing current and generated versions plus the changelog that are generated by `@priestine/semantics` which you can use in your deployment later on

**IMPORTANT NOTE**: If you don't follow [conventional commits](https://www.conventionalcommits.org/en/v1.0.0-beta.2/#specification),
all your commits will be referred to as fixes. This is done to jump into releasing even if you haven't used conventional
commits before.

## WAT?

`@priestine/semantics` uses [conventional commits](https://www.conventionalcommits.org/en/v1.0.0-beta.2/#specification) to determine the types of changes in the codebase and determines the next [semantic version](https://semver.org/), generates a list of changes (a changelog) and publishes appropriate release tag with the changelog attached to it.

## Execution logic

1. Get the latest release tag for the project
2. Obtain the commit that the latest release tag is bound to
3. Get a list of commits since the latest release commit up to the current one
4. Analyze commits
5. Generate changelog for analyzed commits
6. Use API to create a release tag and append the changelog to the release message
7. Put metadata (see [#output](#output)) in temporary files

You can add your own logic in the same job after `@priestine/semantics` has finished running, or assign a separate release job that will run on publishing the tag to GitLab.

## Installation

### Docker and GitLab CI (preferred choice)

The easiest way to use the app is to go get the [Dockerfile from Docker Cloud](https://cloud.docker.com/repository/docker/priestine/semantics). You can create a separate job in your `.gitlab-ci.yml` that will bump your versions. In fact it is as easy as

```yaml
# .gitab-ci.yml

versioning:
  stage: deploy
  image: priestine/semantics:latest
  script:
  - priestine-semantics
  only:
  - master
```

**IMPORTANT NOTE**: Private token is required for publishing new tags to GitLab. You can provide the token via environment variable called `PRIVATE_TOKEN` or explicitly assign it as a `priestine-semantics` argument like so:

```yaml
  # ...
  script:
  - priestine-semantics --private-token=YOUR_TOKEN
  # ...
```

If you do not provide a private token, `@priestine/semantics` will simply omit publishing tag to GitLab. It will still evaluate changes and put temporary files with metadata grabbed during evaluation (see [#output](#output)).

You can learn more about available CLI args and flags [here](#cli-args).

#### `PRIVATE_TOKEN`

Private token env variable is in fact a GitLab user **access token** that is used for publishing tags to GitLab. To create an access token, follow the steps:

1. Go to your profile page (https://gitlab.com/profile)
2. Choose `Access Tokens` in the menu on the left (https://gitlab.com/profile/personal_access_tokens)
3. In the `Name` input, provide something viable like `Semantics`
4. In the **scopes** section, check the `api` checkbox
5. Press the `Create personal access token button`
6. You'll get your newly created access token inside `Your New Personal Access Token` input
7. Copy it and paste it in your private environment variables as `PRIVATE_TOKEN` ([GitLab docs on environment variables](https://docs.gitlab.com/ee/ci/environments.html))

It is a good idea to create a separate user and use it for the releasing purposes.

### Docker image info

[![Docker Pulls](https://img.shields.io/docker/pulls/priestine/semantics.svg)](https://hub.docker.com/r/priestine/semantics/) [![Docker Stars](https://img.shields.io/docker/stars/priestine/semantics.svg)](https://hub.docker.com/r/priestine/semantics/) [![MicroBadger Layers](https://img.shields.io/microbadger/layers/priestine/semantics.svg)](https://hub.docker.com/r/priestine/semantics/) [![MicroBadger Size](https://img.shields.io/microbadger/image-size/priestine/semantics.svg)](https://hub.docker.com/r/priestine/semantics/)

`priestine/semantics:latest` Docker image is built from `node:10-alpine`.

There is also `priestine/semantics@alpine` version which is absolutely equal to `priestine/semantics:latest` as well as `priestine/semantics:slim` based on `node:10-slim`.

Docker images are built on each `priestine/semantics` release so you can stick to the version you are comfortable with, e.g. `priestine/semantics:2.8.0-alpine` or `priestine/semantics:2.8.0-slim`.

### Manual usage

[![npm](https://img.shields.io/npm/dt/@priestine/semantics.svg)](https://www.npmjs.com/package/@priestine/semantics) [![npm](https://img.shields.io/npm/v/@priestine/semantics.svg)](https://www.npmjs.com/package/@priestine/semantics)

If you want to run `@priestine/semantics` yourself locally (or elsewhere except for CI) you will need [Node.js 8 or higher](https://nodejs.org/en/download/) installed on your machine. Simply install the package globally

```bash
yarn global add @priestine/semantics
```

or

```bash
npm i -g @priestine/semantics
```

Then, in your project directory, run:

```bash
priestine-semantics
```

You can also provide [CLI args and flags](#cli-args) to the `priestine-semantics` command.

### CLI args

You can customize the behaviour of `priestine-semantics` command by providing CLI args and flags. To do so, simply provide them after the command itself, e.g.:

```bash
priestine-semantics --custom-domain=https://gitlab.test.com/api/v4 --no-helpers --no-flexible-scope
```

#### Args

* `--private-token=hiImPrivateToken` - private token for publishing tags instead of putting them inside a `PRIVATE_TOKEN` env variable
* `--custom-domain=https://gitlab.test.com/api/v4` - set publishing tags to a GitLab located somewhere other than `https://gitlab.com`. **IMPORTANT NOTE**: always specify the version of the API of your self-hosted GitLab (e.g. `/api/v4`, **don't add the trailing slash**) This is done to allow support for GitLab APIs older than v4 _although it has never been tested_
* `--prefix=v` - set prefix for newly created version (e.g. `v1.0.0`)
* `--postfix=-beta` - set postfix for newly created version (e.g. `1.0.0-beta`)

#### Flags

* `--no-flexible-scope` - out of the box, `@priestine/semantics` supports special behaviour for commit scope (the thing in brackets after the commit type). Currently, it supports extracting issue references from commit scope if the scope starts with a `#`. The `--no-flexible-scope` flag forces `@priestine/semantics` to stop doing stuff with the scope and simply append whatever it contains to the changelog commit description
* `--no-chore` - disables putting **chore** commits to the changelog
* `--no-style` - disables putting **style** commits to the changelog
* `--no-refactor` - disables putting **refactor** commits to the changelog
* `--no-docs` - disables putting **docs** commits to the changelog
* `--no-perf` - disables putting **perf** commits to the changelog
* `--no-test` - disables putting **test** commits to the changelog
* `--no-revert` - disables putting **revert** commits to the changelog
* `--no-ci` - disables putting **ci** commits to the changelog
* `--no-build` - disables putting **build** commits to the changelog
* `--no-fix` - disables putting **fix** commits to the changelog. **This flag does not disable version bumping**
* `--no-feat` - disables putting **feat** commits to the changelog. **This flag does not disable version bumping**
* `--no-bc` - disables putting **BREAKING CHANGES** to the changelog. **This flag does not disable version bumping**
* `--no-helpers` - disables all helper text blocks for commit groups in the changelog (e.g. `Documentation only changes` for `docs` commits)
* `--fix-or-feat` - disables putting anything to changelog but **fix**, **feat** and **BREAKING CHANGE**-containing commits. This is done to make `@priestine/semantics` act like what `semantic-release` does. This flag also disables helpers

### Output

While running, `@priestine/semantics` generates a few temporary files for your disposal.
 
> Temporary file output will only be created if a new release is required.

#### Temporary file description

##### .tmp.current_commit_data (Example)

The commit assigned to the previous tag (if there was previous release tag in place for current project).

```text
4ed93c713f65eff843406a549c740132c99da123

```

##### .tmp.current_tag_data (Example)

Previous tag (if there was previous release tag in place for current project).

```text
2.2.3

```

##### .tmp.version_data (Example)

The version that should be assigned according to the contents of the commits.

```text
2.2.4

```

##### .tmp.current_changes.json (Example)

JSON containing all the commits that were evaluated.

```json
[
  {
    "hash": "4ed93c713f65eff843406a549c740132c99da123",
    "abbrevHash": "4ed93c7",
    "author": {
      "name": "priestine1",
      "email": "priestine1.dev@gmail.com"
    },
    "subject": "Correct writing of normalized changes to JSON",
    "body": [],
    "issueReference": "#25",
    "type": "fix",
    "breakingChanges": []
  },
  {
    "hash": "36af8aaa38cea6613c773ce55390a09d7e5898d0",
    "abbrevHash": "36af8aa",
    "author": {
      "name": "priestine1",
      "email": "priestine1.dev@gmail.com"
    },
    "subject": "Last attempt to fix publishing for today",
    "body": [],
    "issueReference": "#14",
    "type": "fix",
    "breakingChanges": []
  }
]

```

#### .tmp.changelog.md (Example)

Markdown changelog for evaluated commits.

```markdown
# 2.2.4


## Bug Fixes

`A bug fix`

* **4ed93c7**: Correct writing of normalized changes to JSON (**#25**)
* **36af8aa**: Last attempt to fix publishing for today (**#14**)

```

## Badge

Let people know that your package is published using `@priestine/semantics` by including the badge in your README:

```markdown
[![versioning: semantics](https://img.shields.io/badge/versioning-semantics-912e5c.svg)](https://gitlab.com/priestine/semantics)
```
